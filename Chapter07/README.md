<h1 align="center">第 07 章 类 学习笔记</h1>

- [1. 定义抽象数据类型](#1-定义抽象数据类型)
  - [1.1 设计Sales\_data类](#11-设计sales_data类)
  - [1.3 定义类相关的非成员函数](#13-定义类相关的非成员函数)
  - [1.4 构造函数](#14-构造函数)
  - [1.5 拷贝、赋值和析构](#15-拷贝赋值和析构)
- [2. 访问控制与封装](#2-访问控制与封装)
  - [2.1 友元](#21-友元)
  - [2.2 友元的声明](#22-友元的声明)
- [3. 类的其他特性](#3-类的其他特性)
  - [3.1 类成员再探](#31-类成员再探)
  - [3.2 返回 `*this` 的成员函数](#32-返回-this-的成员函数)
  - [3.3 类类型](#33-类类型)
  - [3.5 友元再探](#35-友元再探)
- [4. 类的作用域](#4-类的作用域)
  - [4.1 名字查找与类的作用域](#41-名字查找与类的作用域)
- [5. 构造函数再探](#5-构造函数再探)
  - [5.1 构造函数初始值列表](#51-构造函数初始值列表)
  - [5.2 委托构造函数](#52-委托构造函数)
  - [5.3 默认构造函数的作用](#53-默认构造函数的作用)
  - [5.4 隐式的类类型转换](#54-隐式的类类型转换)
  - [5.5 聚合类](#55-聚合类)
  - [5.5 字面值常量类](#55-字面值常量类)
- [6. 类的静态成员](#6-类的静态成员)

## 1. 定义抽象数据类型
类的基本思想：数据抽象和封装
- **`数据抽象（data abstraction）`** ：依赖于接口和实现分离的编程（以及设计）技术。
  - 类接口：用户所能执行的操作
  - 类实现：类的数据成员、负责接口实现的函数以及定义类所需的各种私有函数。

- **`封装（encapsulation）`**：实现了接口和实现的分离。
  - 封装后的类隐藏了其实现细节。
  - 类的用户只能使用接口而无法访问实现部分。

类如果要实现数据抽象和封装，需要先定义一个抽象数据类型。在抽象数据类型中：
- 类的设计者只考虑类的实现过程。
- 使用该类的人只需要抽象思考类型做了什么，无须了解类型的工作细节。

### 1.1 设计Sales_data类
Sales_data的接又应该包含以下操作:
- 一个isbn成员函数，用于返回对象的ISBN编号
- 一个combine成员函数，用于将一个Sales_data对象加到另一个对象上。
- 一个名为add的函数，执行两个Sales_data对象的加法
- 一个read函数，将数据从istream读入到Sales_data对象中。
- 一个printf函数，将Sales_data对象的值输出到ostream。

```cpp
struct Sales_data{
    // 新成员:关于sales_dat a对象的操作
    std::string isbn() const( return bookNo;} // 参数为空，返回值是string类型
    Sales_data& combine (const Sales_data &);
    double avg _price () const;
    // 将数据成员和2.6.1 节(第64 页)相比没有改变
    std::string bookNo;
    unsigned units_sold = 0；
    double revenue = 0.0;
};
// Sales_data 的 非成 员接又 函数
Sales_data read(const Sales_data&, const Sales_data&);
std::ostream &sprint(std::ostream&, const Sales_data&);
std::istream &read(std::istream&, Sales_data&);

Sales_data total; // 保存当前求和结果的变量
if (read(cin, total)){ // 读入第一笔交易
    Sales_data trans; // 保存下一条交易数据的变量
    while(read(cin, trans)){ // 读入剩余的交易
        if (total.isbn() == trans.isbn()) { // 检查isbn
            total.combine(trans); // 更新变量total当前的值
        } else {
            print(cout, total) <<endl; // 输出结果
            total = trans; // 处理下一本书
        }
    }
    print(cout, total) << endl;
}else {
    cerr << "No data?!" << endl;
}
```
定义在类内部的函数是`隐式的inline函数`。

- 定义成员函数
  - `所有成员`都必须在`类的内部声明`，但`成员函数体`可以定义在`类内`，也可以定义在`类外`。
  - `成员函数体`也是一个`程序块`。

- 引入`this`
  - 成员函数通过一个名为`this`的额外隐式参数来访问调用它的那个对象。
  - 成员函数内部，可以直接使用调用该函数的对象的成员，无须通过`成员访问运算符`来进行。
  - 任何对类成员的`直接访问`都被看作`this的隐式引用`。`this->bookNo`

- 引入`const`成员函数
  - 两种情况：
    - 紧跟函数名之后`const`的作用
      - 修改`隐式this指针`的类型。
    - 紧跟在参数列表后的const的作用
      - 表示`this`是一个指向常量的指针。
  - 默认情况下，`this`的类型是`指向类类型非常量版本`的`常量指针`。
  - 使用`const`的成员函数被称为`常量成员函数`。

  常量对象，以及常量对象的引用或指针都只能调用常量成员函数。

- 类作用域和成员函数
  - 类的成员函数的定义嵌套在类的作用域之内。
  - 编译器分两步处理类：首先编译成员的声明，然后就是成员函数体。

  成员函数体可以随意使用类中的其它成员而无须在意这些成员出现的次序。

- 在类的外部定义成员函数
  - 在类的外部定义成员函数时，成员函数的定义必须与它的声明匹配。
    - 返回类型、参数列表和函数名都得与类内部的声明保持一致。

- 定义一个返回this对象的函数
  ```cpp
  Sales_data& Sales_data::combine(const Sales_data &rhs)
  {
      units_sold += rhs.units_sold; // 把rhs的成员加到this对象的成员上
      revenue += rhs.revenue;
      return *this; // 返回调用该函数的对象
  }
  ```

### 1.3 定义类相关的非成员函数
一般来说，如果非成员函数是类接口的组成部分，则这些函数的声明应该与类在同一个头文件中。

```cpp
istream &read(istream &is, Sales_data &item)
{
    double price = 0;
    is >> item.bookNo >> item.units_sold >> price;
    item.revenue = price * item.units_sold;
    return is;
}

// 对于print函数，不负责换行。
ostream &print(ostream *os, const Sales_data *item)
{
    os << item.isbn() << " " << item.units_sold << " "
        << item.revenue << " " << item.avg_price();
    
    return os;
}
```
一般情况下，执行输出任务的函数应该尽量减少对格式的控制，可以确保由用户代码来决定是否换行。

### 1.4 构造函数
每个类都分别定义了它的对象被初始化的方式，类通过一个或几个特殊的成员函数来控制其对象的初始化过程，这些函数叫做 **`构造函数`**。

**`构造函数的任务`**：初始化类对象的数据成员，无论何时只要类的对象被创建，就会执行构造函数。

构造函数的特点：
- 构造函数的名字和类名相同。
- 构造函数没有返回类型。
- 构造函数也有一个（可能为空）参数列表和一个（可能为空）函数体。

⚠️注意点：不同于其它成员函数，构造函数被声明成const的。构造函数在const对象的构造过程中可以向其写值。

- 合成的默认构造函数
  - 类通过一个特殊的构造函数来控制默认初始化过程，这个函数叫做默认构造函数。默认构造函数无须任何实参。
  - 如果类中没有显式地定义了构造函数，那么编译器就会隐式地定义一个默认构造函数。
    - 编译器创建的构造函数又被称为合成的默认构造函数。
    - 合成的默认构造函数初始化类的数据成员的规则：
      - 如果存在类的初始值，用它来初始化成员。
      - 否则，默认初始化该成员。

- 某些类不能依赖于合成的默认构造函数
  - 合成的默认构造函数只适合非常简单的类。
  - 对于普通的类来说，必须定义它自己的默认构造函数。原因：
    - 编译器只有在发现类不包含任何构造函数的情况下代替生成一个默认的构造函数。
      - 只有当类没有声明任何构造函数时，编译器才会自动地生成默认构造函数。
    - 可能会存在执行错误的操作。
      - 如果类包含有内置类型或者复合类型的成员，则只有当这些成员全都被赋予了类内的初始值时，该类才适合使用合成的默认构造函数。
    - 有时编译器不能为某些类合成默认的构造函数。
      - 必须自定义默认构造函数，否则该类将没有可用的默认构造函数。

- 定义Sales_data的构造函数
  ```cpp
  Sales_data() = default;
  ```

- `=default`的含义
  - C++11标准中，使用 `= default` 可以要求编译器生成构造函数。
  - 可以和`声明在类的内部`（在类内部时，也是内联），也可以作为`定义在类的外部`。

- 构造函数初始值列表
  - 负责为新创建的对象的`一个或几个数据成员初始值`。
  - `构造函数初始值`是成员名字的一个列表，每个名字后面`紧跟括号`括起来的（或者在花括号内的）`成员初始值`。
  - 不同成员的初始化通过`逗号分隔`开。

  构造函数不应该轻易覆盖类内的初始值，除非新赋的值与原值不同。如果不能使用类内初始值，则所有构造函数都应该显式地初始化每个内置类型的成员。

- 在类的外部定义构造函数
  - 需要指明构造函数是哪个类的成员。

  没有出现在构造函数初始化列表中的成员将通过相应的类内初始值初始化，或者执行默认初始化。

### 1.5 拷贝、赋值和析构
除了定义初始化类对象操作外，类还需要控制拷贝、赋值和销毁对象时发生的行为。

- 初始化变量以及以值的方式传递或返回一个对象时会被拷贝。
- 使用赋值运算符时会发生对象的赋值操作。
- 当对象不存在时执行销毁的操作。

如果不主动定义这些操作，则编译器会自动合成。使得编译器生成的版本对对象中的每个成员执行拷贝、赋值和销毁操作。

在一些情况下，编译器合成拷贝、赋值和销毁的操作在一些情况下无法正常使用。当类需要分配类对象之外的资源时，合成的版本常常会失效。


## 2. 访问控制与封装
在C++中，使用 **`访问说明符`** 加强类的封装性：
- 定义在 **`public说明符`** 之后成员在 **`整个程序内可被访问`**，`public` 成员定义 **`类的接口`**。
- 定义在 **`private说明符`** 之后的成员 **`可被被类的成员函数访问`**，但是 **`不能被使用该类的代码访问`**，private部分封装了（即隐藏了）类的`实现细节`。

**`构造函数和部分成员函数`** 紧跟在`public`说明符之后；而 **`数据成员和作为实现部分`** 则跟在 `private` 说明符后面。

- 使用`class`或`struct`关键字
  - 使用`class`关键字而非`struct`开始类的定义。
  - 唯一区别：`struct`和`class`的默认`访问权限`不一样。

### 2.1 友元
类可以允许其他类或者函数访问它的非公有成员，方法是令其它类或者函数成为它的友元。

如果类想把一个函数作为它的友元，只需要增加一条以 `friend` 关键字开始的函数`声明语句`即可。

```cpp
class Sales_data {
    friend Sales_data add(const Sales_data&, const Sales_data&);
    friend std::istream &read(std::istream&, Sales_data&);
    friend std::ostream &print(std::ostream&, const Sales_data&);
public:
    // ......
private:
    // ......
};
```

`友元声明`只能出现在`类定义的内部`，但在类内出现的具体`位置不限`。友元不是类的成员也`不受它所在区域访问控制级别的约束`。

最好在`类定义开始或结来前`的位置`集中声明友元`。

封装的益处：
- 确保用户代码不会无意间破坏封装对象的状态。
- 被封装的类的具体实现细节可以随时改变，而无须调整用户级别的代码。

### 2.2 友元的声明
友元的声明仅仅指定了访问的权限，而非一个通常意义上的函数声明。

为了使友元对类的用户可见，通常是把友元的声明与类本身放置在同一个头文件中（类的外部）。

即使一些编译器支持使用在尚无友元函数的初始声明的情况下调用，但是最好提供一个独立的函数声明。

## 3. 类的其他特性

### 3.1 类成员再探
- 定义一个类型成员
  - 在类中可以`自定义某种类型在类中的别名`，由类定义的类型名字和其它成员一样访问限制，可以是`public`或者`private`中的一种。
    ```cpp
    // 
    class Screen {
    public:
        typedef std::string::size_type pos;
    };
    ```
  - 使用`using`定义类型的成员，必须先定义后使用。
    ```cpp
    class Screen {
    public:
        // 使用类型别名等价于声明一个类型名字
        using pos = std::string::size_type;
    };
    ```
  
  - 类型成员通过出现在类开始的地方。

- 令成员作为内联函数
  - 在类中，常有一些规模较小的函数适合于被声明成内联两数。
    - 定义在类内部的成员函数是`自动inline`的。
  - 可以在`类内`把inline作为声明的一部分`显式地声明成员函数`，也可以在`类的外部用inline关键字`修饰函数的`定义`。

  - 对于inline成员函数也应该与相应的类定义在同一个文件中。

- 重载成员函数
  - 和非成员函数类似，成员函数也可以重载，只要函数之间在参数的数量和/或类型上有所区别就行。
  - 成员函数的匹配过程也是类似。


- 可变数据成员
  - 在一个使用`const成员函数内`，可以通过在变量的声明中加入 `mutable` 关键字来实现`修改类的某个数据成员`。
    ```cpp
    class Screen{
    public:
        // ...
        void some_member() const;
    private:
        mutable size_t access_ctr; // 即是在一个const对象内也可以被修改
    };
    void Screen::some_member() const
    {
        ++access_ctr; // 可修改的可变数据成员
    }
    ```
- 类数据成员的初始值
  - 在C++11中，最好的方式：将默认值声明为一个类内初始值。
  - 初始化时，可以在构造函数中传递一个符合成员类型的实参。
  - 在提供一个`类内初始值`时，必须以`符号=` 或者 `花括号`表示。

- 

### 3.2 返回 `*this` 的成员函数

```cpp
inline Screen &Screen::set(char c)
{
    contents[cursor] = c; // 设置当前光标所在位置的新值
    return *this; // 将this对象作为左值返回
}
```

返回引用的函数是`左值`的，意味着这些函数返回的是`对象本身`而`非对象的副本`。

- 从const成员函数返回 `*this`

  - 一个`const成员函数`如果以`引用`的形式返回 `*this`，那么它的返回类型将是`常量引用`。

- 基于const的重载
  - 通过区分成员函数是否是const，可以对其进行重载，原因：根据参数是否指向const而重载函数的原因类似。

对于公共的代码建议使用私有功能函数。原因：
- 避免多处使用同样的代码。
- 程序规模的增加，函数会变复杂，这样写一处的作用就会凸显。
  - 可以随时增加或者删除信息时比较容易。
- 额外的函数调用不会增加任何开销。
  - 因为在类定义了函数，已经被隐式地被声明成内联函数。

### 3.3 类类型
每个类定义了唯一的类型。

即使两个类的成员列表完全一致，它们也是不同的类型。对于一个类来说，它的成员和其它任何类（或者任何其它作用域）的成员都不是一回事。


- 类的声明
  - 对于类也可以类似函数的声明和定义一样，直接仅声明类而暂时不定义它。
    ```cpp
    class Screen;
    ```
  - 对于这种声明，有时也被称为前向声明，向程序中引入了Screen，并指明它的类型，但是不清楚包含哪些成员。

- 不完全类型
  - 在Screen类声明之后定义之前的这种称为 **`不完全类型`**。
  - 有限的使用场景：
    - 可以定义指向该类型的指针或者引用。
    - 可以声明（但不能定义）以不完全类型作为参数或者返回类型的函数。

从编译器的角度分析：
- 创建类的对象之前必须被定义过，而不仅仅是声明
- 编译器是无法了解需要给对象分配多少存储空间。
- 类必须先被定义，然后才能引用或者指针访问其成员，否则编译器无法确认类中的成员。

### 3.5 友元再探
类可以把其它的类定义成友元，也可以把其它的类的成员函数定义成友元。

友元函数定义在类的内部时，是隐式内联的。

- 类之间的友元关系
  - 如果一个类指定了友元类，则友元类的成员函数可以访问此类包括非公有成员在内的所有成员。
  - 友元关系不存在传递性。所以被声明友元的类里面的友元成员函数，不能访问起其类中的成员。

  每个类都是负责控制自己的友元类或者友元函数。
  
- 函数重载和友元
  - 如果一个类想把一组重载函数声明成它的友元，它需要对这组两数中的每一个分别声明。
    ```cpp
    extern std::ostream& storeOn(std::ostream &, Screen &);
    extern BitMap& storeOn(BitMap &, Screen &);
    class Screen{
        // storeOn 的ostream版本能访问 Screen对象的私有部分
        friend std::ostream& storeOn(std::ostream &, Screen &);
        // ......
    }
    ```

- 友元声明和作用域
  - 类和非成员函数的声明不是必须在它们的友元声明之前。
  - 当一个名字第一次出现在一个友元声明中时，隐式假定该名字在当前作用域内是可见的。
  - 友元本身不一定真的声明在当前作用域中。
  - 在类内部定义友元函数时，也必须在类的外部提供了相应的声明从而使得函数在使用时可见。
    - 有的编译器不强制友元的限定规则。

## 4. 类的作用域
每不类都会定义它自己的作用城。
- 在类的`作用城之外`，普通的数据和两数成员只能由`对象、引用或者指针使用成员访问运算符`来访问。
- 对于`类类型成员`，则使用`作用域运算符访问`。

函数的返回类型通常出现在函数名之前。当成员函数定义在类的外部时，返回类型中使用的名字都位于类的作用域之外。所以返回类型必须要指明它是哪个类的成员。

### 4.1 名字查找与类的作用域
名字查找（寻找与所用名字最匹配的声明的过程）的过程：
- 首先，在名字所在的块中寻找其声明语句，只考虑在名字的使用之前出现的声明。
- 如果没找到，继续查找外层作用域。
- 如果最终没有找到匹配的声明，则程序直接报错。

对于定义在类内部的成员函数，解析其中名字的方式有所区别。类的定义分两步处理：
- 首先，编译成员的声明
- 直到类全部可见后才编译其函数体。

编译器处理完类中的全部声明后才会处理成员函数的定义。

对于一些查找方式的逻辑，可以参考如下：

- 用于类成员声明的名字查找
  - 声明中使用的名字，包括返回类型或者参数列表中使用的名字，都必须在使用之前确保可见。
  - 如果声明中使用了未出现的名字，编译器将会在定义该类的作用域中继续查找。

- 类型名要特殊处理
  - 类型名的定义通常是出现在类的开始处，这样能确保所有使用该类型的成员都出现在类名的定义之后。

- 成员定义中的普通块作用域的名字查找
  - 一般来说，不建议使用其它成员的名字作为某个成员函数的参数。

- 类作用域之后，在外围的作用域中查找
  - 不要随意隐藏外层作用域中可能会被使用到的名字。
    ```cpp
    // 不建议使用该方式
    // 尽管外层的对象被隐藏掉了，但仍然可以使用作用域运算符来进行访问。
    void Screen::dummy_fcn(pos height)
    {
        cursor = width * ::height; // 无法区分是类内的，还是全局的
    }
    ```

- 在文件中名字的出现处对其进行解析
  - 当成员定义在类的外部时，名字查找的第三步不仅要考虑类定义之前的全局作用域中的声明，还需要考虑在成员函数定义之前的全局作用域中的声明。


## 5. 构造函数再探


### 5.1 构造函数初始值列表
如果没有在构造函数的初始值列表中显式地初始化成员，则该数据成员将在构造函数体之前执行默认初始化。

对于通过构造函数初始化值时的一些注意事项：
- 构造函数的初始值有时必不可少
  - 如果数据成员是const或者是引用，必须通过在构造函数初始值列表中将其初始化。
  - 当成员属于某种类型且没有定义默认构造函数时，也必须将数据成员初始化。

- 成员初始化的顺序
  - 在构造函数初始值中每个成员只能出现一次。
  - 对于初始化的顺序没有要求。
  - 构造函数初始值列表中的前后位置关系不会影响实际的初始化顺序。但是建议是最好保持一致，避免使用某些成员初始化其它成员。


- 默认实参和构造函数
  - 如果一个构造函数为所有参数都提供了默认实参，则它实际上也定义了默认构造函数。


### 5.2 委托构造函数
C++11新标准中增加了委托构造函数的概念。

一个委托构造函数使用它所属类的其它构造函数执行它自己的初始化过程。或者说是把自己的一些（或全部）职责委托给了其他构造函数。

当一个构造两数委托给另一个构造函数时，受委托的构造函数的初始值列表和函数体 被依次执行。


### 5.3 默认构造函数的作用
当对象被默认初始化或值初始化时自动执行默认构造函数。

默认初始化在以下情况下发生：
- 当块作用域内不使用任何初始值定义一个非静态变量或者数组时。
- 当一个类本身含有类类型的成员且使用合成的默认构造函数时。
- 当类类型的成员没有在构造函数初始值列表中显式地初始化时。

值初始化在以下情况下发生：
- 在数组初始化的过程中如果提供的初始值少于数组的大小时。
- 当不使用初始值定义一个局部静态变量时。
- 当通过书写形如 `T()` 的表达式显式地请求值初始化时，其中T时类型名的。

在实际生产中，如果定义了其他的构造函数，那么最好也提供一个默认构造函数。

### 5.4 隐式的类类型转换
如果构造函数只接受一个实参，则它实际上定义了转换为此类类型的隐式转换机制，有时把这种构造函数称为 **`转换构造函数`**。

- 只允许一步类类型转换
  - 编译器只会自动地执行一步类型转换。
  - 直接进行转换

- 类类型转换不是总有效

- 抑制构造函数定义的隐式转换
  - 可以通过将构造函数声明为 `explicit` 加以阻止。
    ```cpp
    class Sales_data {
    public:
        Sales_data() = default;
        Sales_data(const std::string &s, unsigned n, double p) : 
                  boookNo(s), units_sold(n),  revenue(p * n) {}
        explicit Sales_data(const std::string &s) : bookNo(s) { }
        explicit Sales_data(std::istream&);
    };
    ```
  - **`关键字 `explicit` 只对一个实参的构造函数有效`**。
  - 需要多个实参的构造函数不能用于执行隐式转换。
  - 只能在`类内声明`构造函数时使用 `explicit`关键字，在`类外部定义`时`无须重复`。

- `explicit`构造函数只能用于直接初始化
  - 发生隐式转换的一种情况是：当执行`拷贝形式`的`初始化`时。
  - 当使用 explicit关键字声明构造函数时，它将只能以直接初始化的形式使用。而且，编译器将不会在自动转换过程中使用该构造函数。

- 为转换显式地使用构造函数
  - 可以使用转换函数直接强制转换。
    ```cpp
    Sales_data item;
    item.combine(static_cast<Sales_data>(cin));
    ```
- 标准库中含有显式构造函数的类
  - 一些标准库的类含有单参数的构造函数。
    - 接受一个`单参数`的`const char *` 的`string构造函数`，`不是explicit`的。
    - 接受一个`容量参数`的`vector`构造函数是 `explicit`。


### 5.5 聚合类
聚合类使得用户可以直接访问其成员，并且具有特殊的初始化语法形式。聚合类需要满足如下条件：
- 所有成员都是public。
- 没有定义任何构造函数。
- 没有类内初始值
- 没有基类，也没有virtual函数。

```cpp
struct Data {
    int val;
    string s;
};
```

但是显式初始化类的对象的成员会存在三个缺点：
- 要求类的所有成员都是public
- 将正确初始化每个对象的每个成员的任务交给用户。
- 添加或删除一个成员后，所有的初始化语句都需要更新。


### 5.5 字面值常量类
`constexpr`函数的`参数`和`返回值`必须是`字面值类型`。除了`算术类型`、`引用`和`指针`外，某些类也是字面值类型。

`数据成员`都是`字面值类型的聚合类`是`字面值常量类`。如果一个类不是聚合类，但满足以下要求的也是一个字面值常量类：
- 数据成员都必须是字面值类型。
- 类必须至少一个constexpr构造函数。
- 如果一个数据成员含有类内初始值，则内置类型成员的初始值必须是一条常量表达式。
- 如果成员属于某种类类型，则初始化必须使用成员自己的constexpr构造函数。

- 类必须使用析构函数的默认定义。
  - 析构函数的作用：
    - 销毁类的对象。

对于constexpr构造函数的使用：
- 一个字面值常量类必须`至少`提供一个 `constexpr` 构造函数。
- `constexpr` 构造函数可以声明成 `=default` 的形式。
- 一般来说，`constexpr`构造函数体是空的。但可以通过前置关键字 `constexpr`声明一个`constexpr构造函数`。

- `constexpr`构造函数必须`初始化所有数据成员`，`初始值`或者使用constexpr构造函数，或者`一条常量表达式`。

- `constexpr`构造函数用于`生成constexpr对象`以及`constexpr函数的参数或返回类型`。


## 6. 类的静态成员

- 声明静态成员
  - 通过在成员的`声明之前`加上关键字 `static`使得与类关联在一起。
  - 静态成员可以是`public`或`private`。
  - 静态数据成员的类型可以是`常量、引用、指针、类类型`等。
  - 类的静态成员存在于任何对象之外，对象中不包含任何与静态数据成员有关的数据。
  - 静态成员函数也不与任何对象绑定在一起，不包含this指针。
  - 静态成员函数`不能声明成const`的，也`不能在static函数体内使用 this指针`。

- 使用类的静态成员
  - 使用`作用域运算符`直接访问静态成员。
  - 成员函数`不用`通过作用域运算符就能直接使用静态成员。

- 定义静态成员
  - 类的外部和内部都可以定义静态成员函数。
  - 在类的外部定义静态成员时，不能重复static关键字，只出现在类内部的声明中即可。
  - 要想确保对象只定义一次，最好的办法：将静态数据成员的定义与其它内联函数的定义放在同一个文件中。

- 静态成员的类内初始化
  - 通常情况下，类的静态成员不应该在类的内部初始化。
  - 如果某个静态成员的应用场景仅限于编译器可以替换它的值的情况，则一个初始化的const或constexpr不需要分别定义。
  - 如果将静态成员用于值不能替换的场景中，则该成员必须有一条定义语句。

- 静态成员能用于某些场景，而普通成员不能
  - 静态成员独立于任何对象。

对于静态成员和普通成员的区别是静态成员作为默认实参。

非静态成员不能作为默认实参，因为它的值本身属于对象的一部分。如果这么做的结果就是无法真正提供一个对象以便于从中获取成员的值，从而引发错误。
