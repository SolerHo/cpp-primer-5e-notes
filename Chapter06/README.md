<h1 align="center">第五章 语句 学习笔记</h1>

- [1. 函数基础](#1-函数基础)
  - [1.1 局部对象](#11-局部对象)
  - [1.2 函数声明](#12-函数声明)
  - [1.3 分离式编译](#13-分离式编译)
- [2. 参数传递](#2-参数传递)
  - [2.1 传值参数](#21-传值参数)
  - [2.2 传引用参数](#22-传引用参数)
  - [2.3 const形参和实参](#23-const形参和实参)
  - [2.4 数组形参](#24-数组形参)
  - [2.5 main: 处理命令行选项](#25-main-处理命令行选项)
  - [2.6 含有可变形参的函数](#26-含有可变形参的函数)
- [3. 返回类型和return语句](#3-返回类型和return语句)
  - [3.1 无返回值函数](#31-无返回值函数)
  - [3.2 有返回值函数](#32-有返回值函数)
  - [3.3 返回数组指针](#33-返回数组指针)
- [4. 函数重载](#4-函数重载)
  - [4.1 重载与作用域](#41-重载与作用域)
- [5. 特殊用途语言特性](#5-特殊用途语言特性)
  - [5.1 默认实参](#51-默认实参)
  - [5.2 内联函数和constexptr函数](#52-内联函数和constexptr函数)
  - [5.3 调试帮助](#53-调试帮助)
- [6. 函数匹配](#6-函数匹配)
  - [6.1 实参数类型转换](#61-实参数类型转换)
- [7. 函数指针](#7-函数指针)

## 1. 函数基础
一个典型的函数定义包括的部分：
- `返回类型`
- `函数名字`
- `由0个或多个形参组成的列表`
  - 形参以逗号隔开。在圆括号内
- `函数体`
  - 程序执行的操作块

调用运算符来执行函数。调用运算符的形式：一对`圆括号()`，圆括号内是一个`逗号隔开`的`实参列表`。使用实参初始化函数的形参。

调用表达式的类型就是函数的返回类型。

- 形参和实参
    - 实参是形参的初始值。
    - 二者的`类型`和`数量`也要一致。
    - 形参列表中的形参通常是常用`逗号`隔开。

函数的`形参列表`可以为`空`，但`不能省略`。

特殊的返回类型是 `void`，表示函数`不返回任何值`。

⚠️注意：函数的返回类型不能是`数组类型`或`函数类型`，但可以是`指向数组`或`函数的指针`。

### 1.1 局部对象
在C++中，**`名字有作用域，对象有生命周期`** 。

- `函数体`是一个`语句块`。块构成一个新的作用域。
- `形参`和`函数体内部定义`的变量统称为 **`局部变量`**。
- 局部变量的生命周期依赖于定义的方式。

在函数体外定义的对象存在与程序的整个执行过程中。
> 生命周期在程序启动时就被创建，直到程序结束才会销毁。

- 自动对象
  - 只存在于块执行期间的对象称为 **`自动对象`**。
  - 普通局部变量对应的对象在函数控制路径经过变量定义语句时创建该对象，当达到定义所在的块末尾时销毁。
  - 当块的执行结束后，块中创建的自动对象的值就会变成未定义的。
  - 形参是一种自动对象。
    - 函数开始时为形参申请存储空间，函数终止面，形参即销毁。

- 局部静态对象
  - 将局部变量定义成static 类型
  - 在程序的执行路径第一次经过对象定义语句时初始化，直到整个程序终止才被销毁。

  ```cpp
  static size_t ctr = 0;
  ```

如果局部静态变量`没有显式初始值`，将`执行值初始化`，`内置`类型的局部静态变量初始化为0。

### 1.2 函数声明
- 函数的名字必须在 **`使用之前声明`**。
- 函数 **`只能定义一次`**，但 **`可声明多次`**。如果一个函数没用到，则可以有声明没有定义。
- 函数声明`无需函数体`，用一个`分号`替代。

函数的`三要素（返回类型、函数名、形参类型）`描述函数的`接口`，说明了调用该函数所需的全部信息。

函数声明也称为 **`函数原型（fucntion prototype）`**。

**`建议变量在头文件中声明，在源文件中定义。函数也是如此`**。
> 含有函数声明的头文件应该被包含到定义函数的源文件中。

### 1.3 分离式编译
C++支持分离式编程。分离式编程允许将程序分割到几个文件中去，每个文件独立编译。

- `编译`和`链接`多个源文件
  - 只修改一个源文件，则只需重新编译改动的文件。
  - 大多数编译器提供`分离式编译`每个文件的机制，此过程中通常是会产生一个后缀名.`obj（Windows）`或`.o（unix/Linux）`的文件。
  - 后缀名的含义是该文件包含对象代码。

## 2. 参数传递
形参初始化的机理与变量初始化一样。相当于将实参的值赋值给形参。

两种传递方式：
- `按值传递`
- `按引用传递`

### 2.1 传值参数
当初始化一个非引用类型的变量时，初始值被拷贝给变量。函数的形参做的所有操作都不会影响实参。

指针可以间接访问它所指的对象，所以可通过指针修改它所指对象的值。

```cpp
// 函数接受一个指针，然后将指针所指的值置为0
void reset(int *ip)
{
  *ip = 0; // 改变指针ip所指对象的值
  ip = 0; // 只改变了ip的局部拷贝，实参未被改变
}
// 调用reset函数后，实参所指的对象被置为0，但实参本身并没有改变。
int i = 42;
reset(&i);  // 改变i的值，非i的地址
cout << " i = " << i << endl; // 输出  i= 0
```


**在C中常常使用`指针类型的形参`来访问`函数外部的对象`。在C++语言中，建议使用`引用类型的形参`替代`指针`。**   

### 2.2 传引用参数
通过引用形参，允许函数改变一个或多个实参的值。
 
```cpp
// 函数接受一个int对象的引用，然后将对象的值置为0
void reset(int &i) // i 是传递给reset函数的对象的另一个名字
{
  i = 0; // 改变了i所引对象的值 
}
```

- 使用引用避免拷贝
  - 解决`拷贝低效`或者`不支持拷贝`。
  - 当某种类型不支持拷贝时，函数只能通过`引用形参`访问该类型的对象。  
  - 使用函数无需改变`引用形参的值`，最好将其声明为`常量引用`。

- 使用引用形参返回额外信息
  - 一个函数只能返回一个值，当函数需要同时返回多个值时则可以使用`引用形参`。

### 2.3 const形参和实参
当形参是const时，当用实参初始化时会忽略掉顶层const。

- 尽量使用常量引用
  - **`防止函数修改实参的值`**
  - 使用普通引用会限制函数所能接受的实参类型。
  - 不能把const对象、字面值或需要类型转换的对象传递给普通的引用形参。

### 2.4 数组形参
数组的两个特殊性质会有限制函数上的参数使用：
- 不允许拷贝数组
  - 所以无法使用按值传递方式使用数组参数。
- 使用数组时会将其转换为指针。
  - 传递数组时，实际传递的是指向数组首元素的指针。

数组是以指针的形式传递给函数的，所以在不确定数组的确切大小时，需要提供数组的大小。所以管理指针形参有三种常用的技术：
- 使用标记`指定数组长度`
- 传递`指向数组首元素和尾元素的指针`。
- 专门`定义一个表示数组大小的形参`（显式传递）。

只要传递给函数的size值不超过数组实际的大小，函数就是安全的。

- 数组形参和const
  - 当函数不需要对数组元素执行写操作时，数组形参是指向const的指针。
  - 只有当函数可改变元素值时，才把形参定义成指向非常量的指针。

- 数组引用形参
    - C++允许将变量定义成`数组的引用`，**`数组也可以是数组的引用`**。
  - 
  ```cpp
  void print(int (&arr)[10]) // &arr 的括号不可少
  {
    for (auto elem : arr)
      cout << elem << endl;
  }
  ```
- 传递多维数组
  
  ```cpp
  // 数组的第一个维度可以省略，但是列数不可省略
  void print(int matrix[][10], int rowSize) {/* ... */}
  ```



### 2.5 main: 处理命令行选项
main函数的空形参列表的格式：
```cpp
int main() { ... }
```

给main函数传递实参：
```cpp
int main(int argc, char *argv[]) {...}
// argv 是一个数组，它的元素是指向C风格字符串的指针。
// argc 表示数组中字符串的数量

// 也可以定义为
int main(int argc, char **argv) {...} // argv指向char*
```
当使用`argv中的实参`时，一定要记得可选的实参从`argv[]`开始，`argv[0]` 保存`程序的名字`，而`非用户输入`。

### 2.6 含有可变形参的函数
为了编写能处理不同数量实参的函数，C++11新标准提供的两种方法：
- 如果`所有的实参类型相同`，可以传递一个名为 `initializer_list` 的标准库类型
- 如果`实参的类型不同`，可以编写一种特殊的函数，也就是 **`可变参数模板`**。

C++中有一种特殊的形参类型（即省略符），可以用它传递可变数量的实参。

- initializer_list 形参
  - 如果函数的`实参数量未知`，但`全部实参的类型都相同`，则可以使用 `initializer_list`类型的`形参`。
  - `initializer_list` 是一种标准库类型，用于表示某种特定类型的值的数组。
  - `initializer_list`类型定义在同名的头文件中。

- 省略符形参
  - 便于C++程序访问某些特殊的C代码而设置的。
  - 仅仅用于C和C++通用的类型。
  - 省略符形参只能出现在形参列表的最后一个位置。
    ```cpp
    void foo(para_list, ...);
    void foo(...);
    ```
  - 省略符形参所对应的实参无须类型检查。

## 3. 返回类型和return语句
return语句终止当前执行的函数并将控制权返回到调用该函数的地方。

return语句的两种形式：
```cpp
return;

return expression;
```

### 3.1 无返回值函数
- 只能用在`返回类型的void`的函数中。
- 直接return。
- void类型函数的最后一句会`隐式执行return`。
- `return`可用于void函数的中间位置`提前退出`。类似于`break`。

### 3.2 有返回值函数
`void语句返回值的类型`必须与`函数的返回类型相同`，或者能`隐式转换`成函数的`返回类型`。

只要函数的返回类型不是void，则函数内的每条return语句必须返回一个值。
  
如果函数返回引用，则引用仅是它所引对象的一个别名。

- 不要返回局部对象的引用或指针
  - 函数完成后，所占用的存储空间也随之释放，函数终止意味着局部变量的引用将指向不再有效的内存区域。

- 返回类类型的函数和调用运算符
  - 如果函数返回指针、引用或类的对象，则可以使用函数调用的结果访问结果对象的成员。
  - 调用运算符的优先级与点运算符和箭头运算符相同，也符合左结合律。

- 引用返回左值
  - 函数的返回类型决定函数调用是否是左值。
  - 调用一个返回引用的函数得到左值，其他返回类型的到右值。
  - 可以为返回类型是非常量引用的函数的结果赋值。
  - 如果返回类型时常量引用，则不能给调用的结果赋值。

- 列表初始化返回值
  - 函数可以返回花括号包围的值的列表。
  - 如果列表为空，临时变量执行值初始化。

- 主函数main的返回值
  - main函数的`结尾`处可以`没有return`语句，编译器将`隐式`插入一条`return 0;`语句。
  - 返回`0`表示`执行成功`，返回`其他值`表示`执行失败`。
  - `cstdlib头文件`中定义了两个预处理变量。
    ```cpp
    int main() {
      // 因为时预处理变量，不能在前面加上 std:: ，也不能在using声明中出现
      if (some_failure)
        return EXIT_FAILURE; // 定义在cstdlib 头文件中
      else
        return EXIT_SUCCESS; // 定义在cstdlib 头文件中
    }
    ```

- 递归
  - 函数间接或直接`调用自身`，都称函数为 **`递归函数（recursive function）`**。
  - 在递归函数中，一定有某条路径是不包含递归调用的，否则，函数会一直递归直到程序栈空间耗尽为止。
  - main函数不能调用它自己。

### 3.3 返回数组指针
因为数组不能被拷贝，所以函数不能返回数组。但函数可以返回数组的指针或引用。

- 声明一个返回数组指针的函数
  - 返回数组指针的函数格式：
    ```cpp
    Type (*function(parameter_list))[dimension];
    // Type 表示元素的类型
    // dimension 表示数组的大小
    // (*function(parameter_list)) 两端的括号必须存在，如果没有，则函数返回类型是指针的数组
    ```

- 使用 **`尾置返回`** 类型
  - `任何函数`都可使用`尾置返回`。
  - 尾置返回类型跟在形参列表后面并以 -> 符号开头。
    ```cpp
    // func接受一个int类型的实参，返回一个指针，该指针指向含有10个整数的数组
    auto func(int i) -> int(*)[10];
    ```

- 使用 decltype
  - 使用 decltype关键字声明返回类型。
  - 可以知道函数返回的指针将指向哪个数组。

## 4. 函数重载
如果同一个作用域内的几个函数名字相同但形参列表不同，则称为 **`函数重载（overload）`**。
> 调用函数时，编译器会根据传递的实参类型推断想要的是哪个函数。

⚠️注意：**main函数不能重载**。

- 定义重载函数
  - 对于重载函数，应该在形参数量或形参类型上有所不同。
  - 不允许两个函数除了返回类型外，其他所有的要素相同。

- 判断两个形参的类型是否相异
  ```cpp
  // 每对声明的是同一个函数
  Record lookup(const Account &acct);
  Record lookup(const Account&); // 省略了形参的列表

  typedef Phone Telno; // Telno 是 Phone 的别名
  Record lookup(const Phone&);
  Record lookup(const Telno&); // Phone 和 Telno 的类型相同
  ```

- 重载和const形参
  - 顶层const不影响传入函数的对象。
  - `顶层const`的形参与`无顶层const`的形参`无法区分`开。
    ```cpp
    Record lookup(Phone);
    Record lookup(const Phone); // 重复声明了Record lookup(Phone);

    Record lookup(Phone*);
    Record lookup(Phone* const); // 重复声明了Record lookup(Phone*);
    ```
  - 如果形参是某种类型的`指针`或`引用`，则通过区分其指向的是`常量对象`还是`非常量对象`可以实现`函数重载`。此时`const是底层`。
    ```cpp
    // 对于接受引用或指针的函数来说，对象是常量还是非常量对应的形参不同
    // 定义了4个独立的重载函数
    Record lookup(Account&);        // 新函数，作用于Account的引用
    Record lookup(const Account&);  // 新函数，作用于常量引用

    Record lookup(Account*);        // 新函数，作用于指向Account的指针
    Record lookup(const Account*); // 新函数，作用于指向常量的指针
    ```

- 调用重载的函数
  - **`函数匹配（重载确定）`**：把函数调用与一组重载函数中的某个关联起来。
  - 编译器会讲调用的实参与重载集合中每一个函数的形参进行比较，然后根据比较的结果决定到底调用哪个函数。
  - 调用重载函数时，可能出现三种情况：
    - 编译器找到一个与实参最佳匹配的函数，并生成调用该函数的代码。
    - 找不到任何一个函数与调用的实参匹配，此时编译器会发出无匹配的错误信息
    - 有多于一个函数可以匹配，但每个都不是明显的最佳选择。此时也会发生错误，称为**`二义性调用（ambiguous call）`**。

### 4.1 重载与作用域
如果在内层作用域中声明名字，将隐藏外层作用域中声明的同名实体。在不用的作用域中无法重载函数名。

在C++中，名字查找发生在类型检查之前。

## 5. 特殊用途语言特性
三个特性：
- 默认实参
- 内联函数
- constexpr函数

### 5.1 默认实参
反复出现的值称为函数的 **`默认实参`**。

调用含有默认实参的函数时，可包含该实参，也可以省略该实参。

默认值也可以有一个或多个形参初始值，但一旦形式参被赋予默认值，则后面的所有形参都必须有默认值。

- 使用默认实参调用函数
  - 在调用函数时`省略实参`即可。
  - 函数调用时，实参按其`位置解析`，默认实参负责填补函数调用缺少的`尾部实参（靠右侧位）`
  - 当设计含有默认实参的函数时，**尽量让不怎么使用默认值的形参出现在前面，让经常使用默认值的形参出现在后面**。

- 默认实参声明
  - 在给定的作用域中一个形参只能被赋予一次默认实参。
  - 通常，应该在函数声明中指定默认实参，并将该声明放在合适的头文件中。

- 默认实参初始值
  - 局部变量不能作为默认实参。
  - 只要表达式的类型能转换成形参所需的类型，则表达式就能作为默认实参。
  - 用作默认实参的名字在函数声明所在的作用域内解析。

### 5.2 内联函数和constexptr函数
对于一个`函数调用`，包含了一系列的操作，但规模小的函数，只要在函数的前面加上`关键字 inline`，即可声明为 **`内联函数`**，从而消`除函数的运行时的开销`。

内联机制用于优化规模较小、流程直接、频繁调用的函数。

很多编译器都不支持内联递归函数。

- `constexpr`函数
  - 能用于`常量表达式`的函数。
  - 函数的`返回类型`及所有`形参的类型`都是`字面值类型`，写`函数体`中必须`有且只有`一条`return语句`。

内联函数和constexpr函数可以在程序中多次定义。但一般是被定义在头文件中。

### 5.3 调试帮助
程序会包含一些用于调试的代码，但只在开发阶段使用。当应用程序编写完成准备发布时，要先屏蔽调试代码。主要用到两个预处理功能：
- **`assert预处理宏`**
  - `assert宏定义`在`cassert`头文件中。
  - `预处理名字`由`预处理器`而`非编译器`管理，所以可以直接使用`预处理名字`而`无须`提供`using声明`。
    ```cpp
    assert(expr);
    // expr表达式为假（0），assert输出信息并终止程序的执行
    // 如果表达式为真（即非0），assert什么也不做
    ```
  - `assert宏`常用于`检查“不能发生”`的条件。

- **`NDEBUG预处理变量`**
  - `assert的行为`依赖于一个名为`NDEBUG`的`预处理变量`的`状态`。
  - 如果定义了`NDEBUG`，则assert`什么也不做`。
  - 默认状态下`没有定义NDEBUG`，此时assert将执行`运行时检查`。
  - 使用一个 `#define`语句`定义NDEBUG`，从而`关闭调试状态`。
  - 定义NDEBUG能避免检查各种条件所需的运行时开销。
  - 可使用 NDEBUG编写自己的条件调试代码。
    - 如果`NDEBUG未定义`，将`执行` `#ifndef` 和 `#endif` 之间的代码。
    - 如果`定义NDEBUG`，则会`忽略` `#ifndef` 和 `#endif` 之间的代码

编译器为每个函数都定义了 __func__，它是`const char` 的一个`静态数组`，用于存放`函数的名字`。

除了`__func__`之外，预处理器定义了其它4个对于程序调试有用的：
- `__FILE__`：存放`文件名`的字符串字面值。
- `__LINE__`：存放`当前行号`的整型字面值
- `__TIME__`：存放`文件编译时间`的字符串字面值
- `__DATE__`：存放`文件编译日期`的字符串字面值。

## 6. 函数匹配
函数匹配的步骤：
- 确定候选函数
  - 确定 **`候选函数`**（集合中的函数叫做候选函数）：选定本次调用对应的重载函数集。
  - 有两个特征：
    - 与`被调用`的函数`同名`
    - 其`声明`在调用点`可见`。
- 确定可行函数
  - 确定 **`可行函数`**（新选出的函数）：从候选函数中选出能被这组实参调用的函数。
  - 有两个特征：
    - 其形参数量与本次调用提供的实参`数量相等`。
    - 每个实参的类型与对应的形参`类型相同`，或者转换成形参的类型。
  - 如果函数`含有默认实参`，则在调用该函数时传入的实参数量可能少于它实际使用的实参数量。
  - 如果`没找到可行函数`，编译器将报告`无匹配函数的错误`。

- 从`可行函数`中选择与`本次调用最匹配`的函数。
  - 实参类型与形参类型越接近，则匹配越好。
  - 编译器依次检查每个实参以确定哪个函数是最佳匹配。
  - 如果没有一个函数可匹配，则`调用错误`，编译器会报告`二义性调用`的信息。

调用重载函数时应尽量避免强制类型转换。如果在实际应用中确实需要强制类型转换，则说明设计的形参集合不合理。

### 6.1 实参数类型转换
如果重载函数的区别在于它的引用类型的形参是否引用了const，或者指针类型的形参是否指向const，则当调用发生时，编译器通过实参是否为常量来决定选择哪个函数。

## 7. 函数指针
函数指针指向的是函数而非对象，指向某种特定类型。

函数的类型由它的返回类型和形参数类型共同决定，与函数名无关。

要声明一个可以`指向该函数的指针`，只需要用`指针`替换`函数名`即可。

```cpp
// pf指向一个函数，该函数的参数是两个 const string的引用，返回值是bool类型
bool (*pf) (const string &, const string &); // 未初始化
// 其中的括号不可少，如果不写，则pf是一个返回值为bool指针的函数。
```


- 使用函数指针
  - 当函数名作为一个值使用时，函数会自动转换成指针。
  - 直接使用指向函数的指针调用该函数，无须提前解引用指针。
  ```cpp
  pf = lengthCompare;   // pf指向名为一个lengthCompare的函数
  pf = &lenghthCompare; // 等价赋值，取地址符可选
  ```

- 重载函数的指针
  - 编译器会通过指针类型来决定使用哪个函数，指针类型必须与重载函数中的某一个精确匹配。

- 函数指针形参
  - 不能定义函数类型的形参，但形参可以是指向函数的指针。
  - 可以直接把函数作为实参使用，会自动转换成指针。

- 返回指向函数的指针
  - 不能返回一个函数，但可返回指向函数类型的指针。
  - 必须将返回类型写成指针形式，编译器不会自动地将函数返回类型当成对应的指针类型来处理。
  - 一般使用类型别名来声明一个返回函数指针的函数
    ```cpp
    using F = int(int*, int);       // F是函数类型，不是指针
    using PF = int(*) (int*, int); // PF是指针类型
    ```
  - 也可以使用`尾置返回`类型的方式声明一个`返回函数指针`的函数
    ```cpp
    auto f1(int) -> int(*) (int*, int);
    ```

- 将auto和decltype用于函数指针类型
  - `decltype` 作用于`某个函数`时，返回`函数类型`而`非指针类型`。
